/* tslint:disable */
/**
 * Creche YAML
 * This is Vivos Creche API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: smulhall79@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import {RequestMethod} from '@angular/http';
import {HttpClient, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../models/models';
import { COLLECTION_FORMATS }                     from '../variables';


  @Injectable()
  export class CrecheApi {
  protected basePath = 'http://__HOST__/v1';
  protected apiKey: string;
  protected accessToken: string;

  constructor(protected http: HttpClient) {

  }

  public setApiKey(apiKey:string) {
  this.apiKey = apiKey;
  }

  public setToken(token:string) {
  this.accessToken = token;
  }

  public setBasePath(basePath:string) {
  this.basePath = basePath;
  }

    /**
    * Add child to system
    * add Child to system
    * @param user 
    * @param body 
    */
      public addChild(user: string, body: models.ChildRequest, extraHttpRequestParams?: any): Observable<models.ChildRequest> {
    return this.addChildWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Child schedule to system
    * Add Child schedule to system
    * @param user 
    * @param body 
    */
      public addChildSchedule(user: string, body: models.ChildSchedule, extraHttpRequestParams?: any): Observable<models.ChildSchedule> {
    return this.addChildScheduleWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * 
    * 
    * @param user 
    * @param body 
    */
      public addGroup(user: string, body: models.Group, extraHttpRequestParams?: any): Observable<models.Group> {
    return this.addGroupWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add staff member to system
    * add Staff to system
    * @param user 
    * @param body 
    */
      public addStaff(user: string, body: models.StaffRequest, extraHttpRequestParams?: any): Observable<{}> {
    return this.addStaffWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add staff shift to the system
    * Add staff shift to the system
    * @param user 
    * @param shift 
    */
      public addStaffShift(user: string, shift: models.Shift, extraHttpRequestParams?: any): Observable<models.Shift> {
    return this.addStaffShiftWithHttpInfo(user, shift, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Signs in or out a child
    * 
    * @param user 
    * @param location 
    * @param date 
    */
      public childTimes(user: string, location: number, date: string, extraHttpRequestParams?: any): Observable<Array<models.TimeSheet>> {
    return this.childTimesWithHttpInfo(user, location, date, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * 
    * 
    * @param user 
    * @param locationId 
    * @param groupId 
    */
      public deleteGroup(user: string, locationId: number, groupId: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteGroupWithHttpInfo(user, locationId, groupId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Delete staff shift from the system
    * Delete staff shift from the system. This shift is a planned shift not the actual worked one
    * @param user 
    * @param id 
    */
      public deleteStaffShift(user: string, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteStaffShiftWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get child in the  system
    * get Child from the system
    * @param user 
    * @param id 
    */
      public getChild(user: string, id: number, extraHttpRequestParams?: any): Observable<models.ChildRequest> {
    return this.getChildWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Child schedules from system
    * Get Child schedules from system
    * @param user 
    * @param locationId 
    * @param groupId 
    * @param startDate 
    * @param endDate 
    */
      public getChildCalculations(user: string, locationId: number, groupId: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<Array<models.ChildCalculations>> {
    return this.getChildCalculationsWithHttpInfo(user, locationId, groupId, startDate, endDate, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Child schedule from the system
    * Get Child schedule from the system
    * @param user 
    * @param childId 
    */
      public getChildSchedule(user: string, childId: number, extraHttpRequestParams?: any): Observable<models.ChildSchedule> {
    return this.getChildScheduleWithHttpInfo(user, childId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Child schedules from system
    * Get Child schedules from system
    * @param user 
    * @param location 
    * @param childIds 
    * @param startDate 
    * @param endDate 
    */
      public getChildSchedules(user: string, location: number, childIds: Array<number>, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<any> {
    return this.getChildSchedulesWithHttpInfo(user, location, childIds, startDate, endDate, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns times for a given child
    * 
    * @param user 
    * @param childId 
    * @param location 
    * @param date 
    */
      public getChildTimes(user: string, childId: number, location: number, date: string, extraHttpRequestParams?: any): Observable<models.TimeSheet> {
    return this.getChildTimesWithHttpInfo(user, childId, location, date, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of children
    * 
    * @param user 
    * @param location 
    */
      public getChildren(user: string, location: number, extraHttpRequestParams?: any): Observable<Array<models.Child>> {
    return this.getChildrenWithHttpInfo(user, location, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of children
    * 
    * @param user 
    * @param locationId 
    */
      public getChildrenByGuardian(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.TimeSheet>> {
    return this.getChildrenByGuardianWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of children
    * 
    * @param user 
    * @param guardianId 
    */
      public getChildrenByGuardianId(user: string, guardianId: number, extraHttpRequestParams?: any): Observable<Array<models.Child>> {
    return this.getChildrenByGuardianIdWithHttpInfo(user, guardianId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * 
    * 
    * @param user 
    */
      public getCreche(user: string, extraHttpRequestParams?: any): Observable<models.Creche> {
    return this.getCrecheWithHttpInfo(user, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Default shifts from the system
    * Get Default shifts from the system
    * @param user 
    * @param locationId 
    */
      public getDefaultStaffShifts(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Shift>> {
    return this.getDefaultStaffShiftsWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of families in the system
    * 
    * @param user 
    * @param locationId 
    */
      public getFamilies(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Family>> {
    return this.getFamiliesWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * 
    * 
    * @param user 
    * @param locationId 
    */
      public getGroups(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Group>> {
    return this.getGroupsWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of guardians
    * 
    * @param user 
    */
      public getGuardians(user: string, extraHttpRequestParams?: any): Observable<Array<models.Guardian>> {
    return this.getGuardiansWithHttpInfo(user, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * 
    * 
    * @param user 
    * @param crecheId 
    */
      public getLocations(user: string, crecheId: number, extraHttpRequestParams?: any): Observable<Array<models.Location>> {
    return this.getLocationsWithHttpInfo(user, crecheId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get the list of schedule types from system
    * GGet the list of schedule types from system
    * @param user 
    * @param locationId 
    */
      public getScheduleTypes(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.ScheduleAndFees>> {
    return this.getScheduleTypesWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of guardians
    * 
    * @param user 
    */
      public getStaff(user: string, extraHttpRequestParams?: any): Observable<Array<models.Staff>> {
    return this.getStaffWithHttpInfo(user, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get rota from the system for a given location
    * Get staff rota from the system for a given location
    * @param user 
    * @param locationId 
    * @param startDate 
    * @param endDate 
    */
      public getStaffRota(user: string, locationId: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<Array<models.Shift>> {
    return this.getStaffRotaWithHttpInfo(user, locationId, startDate, endDate, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get a staff shift from the system
    * Get staff shift from the system. This returns the planned shift not the acutal worked one
    * @param user 
    * @param id 
    */
      public getStaffShift(user: string, id: number, extraHttpRequestParams?: any): Observable<models.Shift> {
    return this.getStaffShiftWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns staff timesheet for today
    * 
    * @param user 
    * @param location 
    */
      public getStaffTimes(user: string, location: number, extraHttpRequestParams?: any): Observable<models.TimeSheet> {
    return this.getStaffTimesWithHttpInfo(user, location, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Gets staff payroll numbers
    * 
    * @param user 
    * @param location 
    * @param startDate 
    * @param endDate 
    */
      public getStaffTimesAndPayroll(user: string, location: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<Array<models.StaffPayroll>> {
    return this.getStaffTimesAndPayrollWithHttpInfo(user, location, startDate, endDate, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Gets staff payroll numbers
    * 
    * @param user 
    * @param location 
    * @param startDate 
    * @param endDate 
    */
      public getStaffTimesAndPayrollV2(user: string, location: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<Array<models.StaffPayroll>> {
    return this.getStaffTimesAndPayrollV2WithHttpInfo(user, location, startDate, endDate, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Return times for a given staff
    * 
    * @param user 
    * @param staffId 
    * @param location 
    * @param date 
    */
      public getStaffTimesById(user: string, staffId: number, location: number, date: string, extraHttpRequestParams?: any): Observable<Array<models.TimeSheet>> {
    return this.getStaffTimesByIdWithHttpInfo(user, staffId, location, date, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Remove child from system
    * remove Child from system
    * @param user 
    * @param id 
    */
      public removeChild(user: string, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.removeChildWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Remove Staff from system
    * remove Staff from system
    * @param user 
    * @param id 
    */
      public removeStaff(user: string, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.removeStaffWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Resets times for children
    * 
    * @param user 
    * @param childId 
    * @param date Sign in/out info
    */
      public resetChildTimes(user: string, childId: number, date: string, extraHttpRequestParams?: any): Observable<{}> {
    return this.resetChildTimesWithHttpInfo(user, childId, date, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Resets times for staff
    * 
    * @param user 
    * @param staffId 
    * @param date Sign in/out info
    */
      public resetStaffTimes(user: string, staffId: number, date: string, extraHttpRequestParams?: any): Observable<{}> {
    return this.resetStaffTimesWithHttpInfo(user, staffId, date, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Signs in or out a child
    * 
    * @param user 
    * @param location 
    * @param childId 
    * @param body Sign in/out info
    */
      public signInOutChild(user: string, location: number, childId: number, body: models.TimeSheetEntry, extraHttpRequestParams?: any): Observable<{}> {
    return this.signInOutChildWithHttpInfo(user, location, childId, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Signs in or out a staff
    * 
    * @param user 
    * @param location 
    * @param staffId 
    * @param body Sign in/out info
    */
      public signInOutStaff(user: string, location: number, staffId: number, body: models.TimeSheetEntry, extraHttpRequestParams?: any): Observable<{}> {
    return this.signInOutStaffWithHttpInfo(user, location, staffId, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Signs in or out a child
    * 
    * @param user 
    * @param location 
    * @param date 
    */
      public staffTimes(user: string, location: number, date: string, extraHttpRequestParams?: any): Observable<Array<models.TimeSheet>> {
    return this.staffTimesWithHttpInfo(user, location, date, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update child in the system
    * Update Child in the system
    * @param user 
    * @param body 
    */
      public updateChild(user: string, body: models.ChildRequest, extraHttpRequestParams?: any): Observable<models.ChildRequest> {
    return this.updateChildWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update Child schedule to system
    * Update Child schedule to system
    * @param user 
    * @param body 
    */
      public updateChildSchedule(user: string, body: models.ChildSchedule, extraHttpRequestParams?: any): Observable<models.ChildSchedule> {
    return this.updateChildScheduleWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update staff shift to the system
    * Update staff shift to the system
    * @param user 
    * @param id 
    * @param shift 
    */
      public updateStaffShift(user: string, id: number, shift: models.Shift, extraHttpRequestParams?: any): Observable<models.Shift> {
    return this.updateStaffShiftWithHttpInfo(user, id, shift, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Updates a worked staff shift
    * Updates a worked staff shift
    * @param user 
    * @param id 
    * @param shift 
    */
      public updateWorkedShift(user: string, id: number, shift: models.WorkedShift, extraHttpRequestParams?: any): Observable<models.WorkedShift> {
    return this.updateWorkedShiftWithHttpInfo(user, id, shift, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }


      /**
      * Add child to system
      * add Child to system
    * @param user 
    * @param body 
    */
      public addChildWithHttpInfo(user: string, body: models.ChildRequest, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addChild.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addChild.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Child schedule to system
      * Add Child schedule to system
    * @param user 
    * @param body 
    */
      public addChildScheduleWithHttpInfo(user: string, body: models.ChildSchedule, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/schedule'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addChildSchedule.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addChildSchedule.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * 
      * 
    * @param user 
    * @param body 
    */
      public addGroupWithHttpInfo(user: string, body: models.Group, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/group'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addGroup.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addGroup.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add staff member to system
      * add Staff to system
    * @param user 
    * @param body 
    */
      public addStaffWithHttpInfo(user: string, body: models.StaffRequest, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/addStaff'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addStaff.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addStaff.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add staff shift to the system
      * Add staff shift to the system
    * @param user 
    * @param shift 
    */
      public addStaffShiftWithHttpInfo(user: string, shift: models.Shift, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/shift'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addStaffShift.');
          }
          // verify required parameter 'shift' is not null or undefined
          if (shift === null || shift === undefined) {
            throw new Error('Required parameter shift was null or undefined when calling addStaffShift.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: shift == null ? '' : JSON.stringify(shift), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Signs in or out a child
      * 
    * @param user 
    * @param location 
    * @param date 
    */
      public childTimesWithHttpInfo(user: string, location: number, date: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/times/${location}/${date}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location))
        .replace('${' + 'date' + '}', String(date));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling childTimes.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling childTimes.');
          }
          // verify required parameter 'date' is not null or undefined
          if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling childTimes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * 
      * 
    * @param user 
    * @param locationId 
    * @param groupId 
    */
      public deleteGroupWithHttpInfo(user: string, locationId: number, groupId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/group/${locationId}/${groupId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'groupId' + '}', String(groupId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteGroup.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteGroup.');
          }
          // verify required parameter 'groupId' is not null or undefined
          if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteGroup.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Delete staff shift from the system
      * Delete staff shift from the system. This shift is a planned shift not the actual worked one
    * @param user 
    * @param id 
    */
      public deleteStaffShiftWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/shift/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteStaffShift.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteStaffShift.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get child in the  system
      * get Child from the system
    * @param user 
    * @param id 
    */
      public getChildWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChild.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChild.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Child schedules from system
      * Get Child schedules from system
    * @param user 
    * @param locationId 
    * @param groupId 
    * @param startDate 
    * @param endDate 
    */
      public getChildCalculationsWithHttpInfo(user: string, locationId: number, groupId: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/schedules/calculate/${locationId}/${groupId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'groupId' + '}', String(groupId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildCalculations.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildCalculations.');
          }
          // verify required parameter 'groupId' is not null or undefined
          if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getChildCalculations.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getChildCalculations.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getChildCalculations.');
          }
          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Child schedule from the system
      * Get Child schedule from the system
    * @param user 
    * @param childId 
    */
      public getChildScheduleWithHttpInfo(user: string, childId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/schedule/${childId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'childId' + '}', String(childId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildSchedule.');
          }
          // verify required parameter 'childId' is not null or undefined
          if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling getChildSchedule.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Child schedules from system
      * Get Child schedules from system
    * @param user 
    * @param location 
    * @param childIds 
    * @param startDate 
    * @param endDate 
    */
      public getChildSchedulesWithHttpInfo(user: string, location: number, childIds: Array<number>, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/schedules/${location}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildSchedules.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getChildSchedules.');
          }
          // verify required parameter 'childIds' is not null or undefined
          if (childIds === null || childIds === undefined) {
            throw new Error('Required parameter childIds was null or undefined when calling getChildSchedules.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getChildSchedules.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getChildSchedules.');
          }
          if (childIds) {
            queryParameters = queryParameters.set('childIds', childIds.join(COLLECTION_FORMATS['csv']));
          }

          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns times for a given child
      * 
    * @param user 
    * @param childId 
    * @param location 
    * @param date 
    */
      public getChildTimesWithHttpInfo(user: string, childId: number, location: number, date: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child-times/${childId}/${location}/${date}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'childId' + '}', String(childId))
        .replace('${' + 'location' + '}', String(location))
        .replace('${' + 'date' + '}', String(date));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildTimes.');
          }
          // verify required parameter 'childId' is not null or undefined
          if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling getChildTimes.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getChildTimes.');
          }
          // verify required parameter 'date' is not null or undefined
          if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling getChildTimes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of children
      * 
    * @param user 
    * @param location 
    */
      public getChildrenWithHttpInfo(user: string, location: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/children/${location}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildren.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getChildren.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of children
      * 
    * @param user 
    * @param locationId 
    */
      public getChildrenByGuardianWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/${locationId}/children-guardian'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildrenByGuardian.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildrenByGuardian.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of children
      * 
    * @param user 
    * @param guardianId 
    */
      public getChildrenByGuardianIdWithHttpInfo(user: string, guardianId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/children-guardian/${guardianId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'guardianId' + '}', String(guardianId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildrenByGuardianId.');
          }
          // verify required parameter 'guardianId' is not null or undefined
          if (guardianId === null || guardianId === undefined) {
            throw new Error('Required parameter guardianId was null or undefined when calling getChildrenByGuardianId.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * 
      * 
    * @param user 
    */
      public getCrecheWithHttpInfo(user: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/creche'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getCreche.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Default shifts from the system
      * Get Default shifts from the system
    * @param user 
    * @param locationId 
    */
      public getDefaultStaffShiftsWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/${locationId}/staff/shifts'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getDefaultStaffShifts.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getDefaultStaffShifts.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of families in the system
      * 
    * @param user 
    * @param locationId 
    */
      public getFamiliesWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/families/${locationId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getFamilies.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getFamilies.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * 
      * 
    * @param user 
    * @param locationId 
    */
      public getGroupsWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/groups/${locationId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getGroups.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getGroups.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of guardians
      * 
    * @param user 
    */
      public getGuardiansWithHttpInfo(user: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/guardians'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getGuardians.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * 
      * 
    * @param user 
    * @param crecheId 
    */
      public getLocationsWithHttpInfo(user: string, crecheId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/locations/${crecheId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'crecheId' + '}', String(crecheId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getLocations.');
          }
          // verify required parameter 'crecheId' is not null or undefined
          if (crecheId === null || crecheId === undefined) {
            throw new Error('Required parameter crecheId was null or undefined when calling getLocations.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get the list of schedule types from system
      * GGet the list of schedule types from system
    * @param user 
    * @param locationId 
    */
      public getScheduleTypesWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/schedules/${locationId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getScheduleTypes.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getScheduleTypes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of guardians
      * 
    * @param user 
    */
      public getStaffWithHttpInfo(user: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaff.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get rota from the system for a given location
      * Get staff rota from the system for a given location
    * @param user 
    * @param locationId 
    * @param startDate 
    * @param endDate 
    */
      public getStaffRotaWithHttpInfo(user: string, locationId: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/rota/${locationId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffRota.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getStaffRota.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getStaffRota.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getStaffRota.');
          }
          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get a staff shift from the system
      * Get staff shift from the system. This returns the planned shift not the acutal worked one
    * @param user 
    * @param id 
    */
      public getStaffShiftWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/shift/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffShift.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStaffShift.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns staff timesheet for today
      * 
    * @param user 
    * @param location 
    */
      public getStaffTimesWithHttpInfo(user: string, location: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff-times/${location}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimes.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Gets staff payroll numbers
      * 
    * @param user 
    * @param location 
    * @param startDate 
    * @param endDate 
    */
      public getStaffTimesAndPayrollWithHttpInfo(user: string, location: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/payroll/${location}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimesAndPayroll.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimesAndPayroll.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getStaffTimesAndPayroll.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getStaffTimesAndPayroll.');
          }
          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Gets staff payroll numbers
      * 
    * @param user 
    * @param location 
    * @param startDate 
    * @param endDate 
    */
      public getStaffTimesAndPayrollV2WithHttpInfo(user: string, location: number, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/payroll/v2/${location}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimesAndPayrollV2.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimesAndPayrollV2.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getStaffTimesAndPayrollV2.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getStaffTimesAndPayrollV2.');
          }
          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Return times for a given staff
      * 
    * @param user 
    * @param staffId 
    * @param location 
    * @param date 
    */
      public getStaffTimesByIdWithHttpInfo(user: string, staffId: number, location: number, date: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff-times/${staffId}/${location}/${date}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'staffId' + '}', String(staffId))
        .replace('${' + 'location' + '}', String(location))
        .replace('${' + 'date' + '}', String(date));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimesById.');
          }
          // verify required parameter 'staffId' is not null or undefined
          if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling getStaffTimesById.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimesById.');
          }
          // verify required parameter 'date' is not null or undefined
          if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling getStaffTimesById.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Remove child from system
      * remove Child from system
    * @param user 
    * @param id 
    */
      public removeChildWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/remove/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling removeChild.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeChild.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Remove Staff from system
      * remove Staff from system
    * @param user 
    * @param id 
    */
      public removeStaffWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/remove/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling removeStaff.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeStaff.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Resets times for children
      * 
    * @param user 
    * @param childId 
    * @param date Sign in/out info
    */
      public resetChildTimesWithHttpInfo(user: string, childId: number, date: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/reset-times/${childId}/${date}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'childId' + '}', String(childId))
        .replace('${' + 'date' + '}', String(date));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling resetChildTimes.');
          }
          // verify required parameter 'childId' is not null or undefined
          if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling resetChildTimes.');
          }
          // verify required parameter 'date' is not null or undefined
          if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling resetChildTimes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Resets times for staff
      * 
    * @param user 
    * @param staffId 
    * @param date Sign in/out info
    */
      public resetStaffTimesWithHttpInfo(user: string, staffId: number, date: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/reset-times/${staffId}/${date}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'staffId' + '}', String(staffId))
        .replace('${' + 'date' + '}', String(date));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling resetStaffTimes.');
          }
          // verify required parameter 'staffId' is not null or undefined
          if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling resetStaffTimes.');
          }
          // verify required parameter 'date' is not null or undefined
          if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling resetStaffTimes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Signs in or out a child
      * 
    * @param user 
    * @param location 
    * @param childId 
    * @param body Sign in/out info
    */
      public signInOutChildWithHttpInfo(user: string, location: number, childId: number, body: models.TimeSheetEntry, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/sign-in-out/${location}/${childId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location))
        .replace('${' + 'childId' + '}', String(childId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling signInOutChild.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling signInOutChild.');
          }
          // verify required parameter 'childId' is not null or undefined
          if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling signInOutChild.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signInOutChild.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Signs in or out a staff
      * 
    * @param user 
    * @param location 
    * @param staffId 
    * @param body Sign in/out info
    */
      public signInOutStaffWithHttpInfo(user: string, location: number, staffId: number, body: models.TimeSheetEntry, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/sign-in-out/${location}/${staffId}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location))
        .replace('${' + 'staffId' + '}', String(staffId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling signInOutStaff.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling signInOutStaff.');
          }
          // verify required parameter 'staffId' is not null or undefined
          if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling signInOutStaff.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signInOutStaff.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Signs in or out a child
      * 
    * @param user 
    * @param location 
    * @param date 
    */
      public staffTimesWithHttpInfo(user: string, location: number, date: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/times/${location}/${date}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'location' + '}', String(location))
        .replace('${' + 'date' + '}', String(date));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling staffTimes.');
          }
          // verify required parameter 'location' is not null or undefined
          if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling staffTimes.');
          }
          // verify required parameter 'date' is not null or undefined
          if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling staffTimes.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update child in the system
      * Update Child in the system
    * @param user 
    * @param body 
    */
      public updateChildWithHttpInfo(user: string, body: models.ChildRequest, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateChild.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateChild.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update Child schedule to system
      * Update Child schedule to system
    * @param user 
    * @param body 
    */
      public updateChildScheduleWithHttpInfo(user: string, body: models.ChildSchedule, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/child/schedule'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateChildSchedule.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateChildSchedule.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update staff shift to the system
      * Update staff shift to the system
    * @param user 
    * @param id 
    * @param shift 
    */
      public updateStaffShiftWithHttpInfo(user: string, id: number, shift: models.Shift, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/shift/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateStaffShift.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateStaffShift.');
          }
          // verify required parameter 'shift' is not null or undefined
          if (shift === null || shift === undefined) {
            throw new Error('Required parameter shift was null or undefined when calling updateStaffShift.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: shift == null ? '' : JSON.stringify(shift), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Updates a worked staff shift
      * Updates a worked staff shift
    * @param user 
    * @param id 
    * @param shift 
    */
      public updateWorkedShiftWithHttpInfo(user: string, id: number, shift: models.WorkedShift, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/${user}/staff/worked-shift/${id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateWorkedShift.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateWorkedShift.');
          }
          // verify required parameter 'shift' is not null or undefined
          if (shift === null || shift === undefined) {
            throw new Error('Required parameter shift was null or undefined when calling updateWorkedShift.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: shift == null ? '' : JSON.stringify(shift), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }


    /**
    * @param consumes string[] mime-types
    * @return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (let consume of consumes) {
    if (form === consume) {
    return true;
    }
    }
    return false;
    }


    private searchToObject(): {[key :string]: string} {
    let pairs = window.location.search.substring(1).split("&"),
    obj = {},
    pair,
    i;

    for ( i in pairs ) {
    if ( pairs[i] === "" ) continue;

    pair = pairs[i].split("=");
    obj[ decodeURIComponent( pair[0] ) ] = decodeURIComponent( pair[1] );
    }

    return obj;
    }

    /**
    * Converts RequestMethod to string
    * @param {RequestMethod} method
    * @returns {string}
    */
    protected requestMethodToString(method: RequestMethod): string {
    switch (method) {
    case RequestMethod.Delete:
    return 'DELETE';

    case RequestMethod.Get:
    return 'GET';

    case RequestMethod.Head:
    return 'HEAD';

    case RequestMethod.Options:
    return 'OPTIONS';

    case RequestMethod.Patch:
    return 'PATCH';

    case RequestMethod.Post:
    return 'POST';

    case RequestMethod.Put:
    return 'PUT';

    default:
    throw 'Unknown method: ' + method;
    }
    }
    }
