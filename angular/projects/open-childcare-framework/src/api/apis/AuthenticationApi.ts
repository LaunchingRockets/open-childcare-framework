/* tslint:disable */
/**
 * Creche YAML
 * This is Vivos Creche API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: smulhall79@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import {RequestMethod} from '@angular/http';
import {HttpClient, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../models/models';
import { COLLECTION_FORMATS }                     from '../variables';


  @Injectable()
  export class AuthenticationApi {
  protected basePath = 'http://__HOST__/v1';
  protected apiKey: string;
  protected accessToken: string;

  constructor(protected http: HttpClient) {

  }

  public setApiKey(apiKey:string) {
  this.apiKey = apiKey;
  }

  public setToken(token:string) {
  this.accessToken = token;
  }

  public setBasePath(basePath:string) {
  this.basePath = basePath;
  }

    /**
    * Authentication API
    * 
    * @param user 
    * @param body 
    */
      public addUserRoles(user: string, body: models.User, extraHttpRequestParams?: any): Observable<{}> {
    return this.addUserRolesWithHttpInfo(user, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param user Generate access code
    * @param locationId 
    * @param type 
    * @param id 
    * @param method 
    */
      public generateAccess(user: string, locationId: number, type: string, id: number, method?: string, extraHttpRequestParams?: any): Observable<models.Code> {
    return this.generateAccessWithHttpInfo(user, locationId, type, id, method, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param user 
    * @param id 
    */
      public getUserInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<models.User> {
    return this.getUserInfoWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param body Login request
    */
      public login(body: models.Login, extraHttpRequestParams?: any): Observable<models.User> {
    return this.loginWithHttpInfo(body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param type 
    * @param body Login request
    */
      public loginByCode(type: string, body: models.Login, extraHttpRequestParams?: any): Observable<models.User> {
    return this.loginByCodeWithHttpInfo(type, body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    */
      public logout(extraHttpRequestParams?: any): Observable<{}> {
    return this.logoutWithHttpInfo(extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param body 
    */
      public register(body: models.Register, extraHttpRequestParams?: any): Observable<models.User> {
    return this.registerWithHttpInfo(body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param body 
    */
      public resetPassword(body: models.Register, extraHttpRequestParams?: any): Observable<models.User> {
    return this.resetPasswordWithHttpInfo(body, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Authentication API
    * 
    * @param user 
    * @param type 
    * @param guardianList 
    */
      public sendAccess(user: string, type: string, guardianList: models.GuardianList, extraHttpRequestParams?: any): Observable<models.Code> {
    return this.sendAccessWithHttpInfo(user, type, guardianList, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }


      /**
      * Authentication API
      * 
    * @param user 
    * @param body 
    */
      public addUserRolesWithHttpInfo(user: string, body: models.User, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/user/roles'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addUserRoles.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addUserRoles.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param user Generate access code
    * @param locationId 
    * @param type 
    * @param id 
    * @param method 
    */
      public generateAccessWithHttpInfo(user: string, locationId: number, type: string, id: number, method?: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/generate-access/{type}/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'type' + '}', String(type))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling generateAccess.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling generateAccess.');
          }
          // verify required parameter 'type' is not null or undefined
          if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling generateAccess.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling generateAccess.');
          }
          if (method !== undefined) {
            queryParameters = queryParameters.set('method', <any>method);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param user 
    * @param id 
    */
      public getUserInfoWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/user-info/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserInfo.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInfo.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param body Login request
    */
      public loginWithHttpInfo(body: models.Login, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/login';

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling login.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param type 
    * @param body Login request
    */
      public loginByCodeWithHttpInfo(type: string, body: models.Login, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/login-by-code/{type}'
        .replace('${' + 'type' + '}', String(type));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'type' is not null or undefined
          if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling loginByCode.');
          }
          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling loginByCode.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    */
      public logoutWithHttpInfo(extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/logout';

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }


      // to determine the Accept header
      let produces: string[] = [
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param body 
    */
      public registerWithHttpInfo(body: models.Register, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/register';

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling register.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param body 
    */
      public resetPasswordWithHttpInfo(body: models.Register, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/reset/password';

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'body' is not null or undefined
          if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling resetPassword.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Authentication API
      * 
    * @param user 
    * @param type 
    * @param guardianList 
    */
      public sendAccessWithHttpInfo(user: string, type: string, guardianList: models.GuardianList, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/send-access/{type}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'type' + '}', String(type));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling sendAccess.');
          }
          // verify required parameter 'type' is not null or undefined
          if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling sendAccess.');
          }
          // verify required parameter 'guardianList' is not null or undefined
          if (guardianList === null || guardianList === undefined) {
            throw new Error('Required parameter guardianList was null or undefined when calling sendAccess.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: guardianList == null ? '' : JSON.stringify(guardianList), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }


    /**
    * @param consumes string[] mime-types
    * @return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (let consume of consumes) {
    if (form === consume) {
    return true;
    }
    }
    return false;
    }


    private searchToObject(): {[key :string]: string} {
    let pairs = window.location.search.substring(1).split("&"),
    obj = {},
    pair,
    i;

    for ( i in pairs ) {
    if ( pairs[i] === "" ) continue;

    pair = pairs[i].split("=");
    obj[ decodeURIComponent( pair[0] ) ] = decodeURIComponent( pair[1] );
    }

    return obj;
    }

    /**
    * Converts RequestMethod to string
    * @param {RequestMethod} method
    * @returns {string}
    */
    protected requestMethodToString(method: RequestMethod): string {
    switch (method) {
    case RequestMethod.Delete:
    return 'DELETE';

    case RequestMethod.Get:
    return 'GET';

    case RequestMethod.Head:
    return 'HEAD';

    case RequestMethod.Options:
    return 'OPTIONS';

    case RequestMethod.Patch:
    return 'PATCH';

    case RequestMethod.Post:
    return 'POST';

    case RequestMethod.Put:
    return 'PUT';

    default:
    throw 'Unknown method: ' + method;
    }
    }
    }
