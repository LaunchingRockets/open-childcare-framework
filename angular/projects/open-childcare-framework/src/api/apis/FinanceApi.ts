/* tslint:disable */
/**
 * Creche YAML
 * This is Vivos Creche API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: smulhall79@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import {RequestMethod} from '@angular/http';
import {HttpClient, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../models/models';
import { COLLECTION_FORMATS }                     from '../variables';


  @Injectable()
  export class FinanceApi {
  protected basePath = 'http://__HOST__/v1';
  protected apiKey: string;
  protected accessToken: string;

  constructor(protected http: HttpClient) {

  }

  public setApiKey(apiKey:string) {
  this.apiKey = apiKey;
  }

  public setToken(token:string) {
  this.accessToken = token;
  }

  public setBasePath(basePath:string) {
  this.basePath = basePath;
  }

    /**
    * Get location message
    * 
    * @param user 
    * @param locationId 
    * @param message 
    */
      public addLocationMessage(user: string, locationId: number, message: models.LocationMessage, extraHttpRequestParams?: any): Observable<models.LocationMessage> {
    return this.addLocationMessageWithHttpInfo(user, locationId, message, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Updates a financial transaction
    * 
    * @param user 
    * @param transaction 
    */
      public addTransaction(user: string, transaction: models.Transaction, extraHttpRequestParams?: any): Observable<models.Transaction> {
    return this.addTransactionWithHttpInfo(user, transaction, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Raises invoice
    * 
    * @param user 
    * @param invoice 
    */
      public createInvoice(user: string, invoice: models.Invoice, extraHttpRequestParams?: any): Observable<models.Invoice> {
    return this.createInvoiceWithHttpInfo(user, invoice, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Raises invoice
    * 
    * @param user 
    * @param id 
    */
      public deleteInvoice(user: string, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteInvoiceWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Delete location message
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteLocationMessage(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteLocationMessageWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Deletes a financial transaction
    * 
    * @param user 
    * @param id 
    */
      public deleteTransaction(user: string, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteTransactionWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get location messages
    * 
    * @param user 
    * @param locationId 
    */
      public getAllLocationMessages(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.LocationMessage>> {
    return this.getAllLocationMessagesWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Raises invoice
    * 
    * @param user 
    * @param id 
    */
      public getInvoice(user: string, id: number, extraHttpRequestParams?: any): Observable<models.Invoice> {
    return this.getInvoiceWithHttpInfo(user, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list of invoices
    * 
    * @param user 
    * @param startDate 
    * @param endDate 
    * @param paid 
    */
      public getInvoices(user: string, startDate: string, endDate: string, paid?: boolean, extraHttpRequestParams?: any): Observable<Array<models.Invoice>> {
    return this.getInvoicesWithHttpInfo(user, startDate, endDate, paid, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get location message
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getLocationMessage(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<models.LocationMessage> {
    return this.getLocationMessageWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Returns list financial transactions
    * 
    * @param user 
    * @param startDate 
    * @param endDate 
    */
      public getTransactions(user: string, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<Array<models.Transaction>> {
    return this.getTransactionsWithHttpInfo(user, startDate, endDate, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * uploads a csv in inserts bank transactions
    * 
    * @param user User ID
    * @param locationId location
    * @param additionalMetadata Additional data to pass to server
    * @param file file to upload
    */
      public importTransactions(user: string, locationId: number, additionalMetadata?: string, file?: any, extraHttpRequestParams?: any): Observable<models.FileResponse> {
    return this.importTransactionsWithHttpInfo(user, locationId, additionalMetadata, file, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Raises invoice
    * 
    * @param user 
    * @param id 
    * @param invoice 
    */
      public updateInvoice(user: string, id: number, invoice: models.Invoice, extraHttpRequestParams?: any): Observable<models.Invoice> {
    return this.updateInvoiceWithHttpInfo(user, id, invoice, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update location message
    * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param message 
    */
      public updateLocationMessage(user: string, locationId: number, id: number, message: models.LocationMessage, extraHttpRequestParams?: any): Observable<models.LocationMessage> {
    return this.updateLocationMessageWithHttpInfo(user, locationId, id, message, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Updates a financial transaction
    * 
    * @param user 
    * @param id 
    * @param transaction 
    */
      public updateTransaction(user: string, id: number, transaction: models.Transaction, extraHttpRequestParams?: any): Observable<models.Transaction> {
    return this.updateTransactionWithHttpInfo(user, id, transaction, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }


      /**
      * Get location message
      * 
    * @param user 
    * @param locationId 
    * @param message 
    */
      public addLocationMessageWithHttpInfo(user: string, locationId: number, message: models.LocationMessage, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/messages'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addLocationMessage.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addLocationMessage.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling addLocationMessage.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Updates a financial transaction
      * 
    * @param user 
    * @param transaction 
    */
      public addTransactionWithHttpInfo(user: string, transaction: models.Transaction, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/transaction'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addTransaction.');
          }
          // verify required parameter 'transaction' is not null or undefined
          if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling addTransaction.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: transaction == null ? '' : JSON.stringify(transaction), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Raises invoice
      * 
    * @param user 
    * @param invoice 
    */
      public createInvoiceWithHttpInfo(user: string, invoice: models.Invoice, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/invoice'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling createInvoice.');
          }
          // verify required parameter 'invoice' is not null or undefined
          if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling createInvoice.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: invoice == null ? '' : JSON.stringify(invoice), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Raises invoice
      * 
    * @param user 
    * @param id 
    */
      public deleteInvoiceWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/invoice/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteInvoice.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteInvoice.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Delete location message
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteLocationMessageWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/messages/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteLocationMessage.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteLocationMessage.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteLocationMessage.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Deletes a financial transaction
      * 
    * @param user 
    * @param id 
    */
      public deleteTransactionWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/transaction/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteTransaction.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTransaction.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get location messages
      * 
    * @param user 
    * @param locationId 
    */
      public getAllLocationMessagesWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/messages'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getAllLocationMessages.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getAllLocationMessages.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Raises invoice
      * 
    * @param user 
    * @param id 
    */
      public getInvoiceWithHttpInfo(user: string, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/invoice/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getInvoice.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInvoice.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list of invoices
      * 
    * @param user 
    * @param startDate 
    * @param endDate 
    * @param paid 
    */
      public getInvoicesWithHttpInfo(user: string, startDate: string, endDate: string, paid?: boolean, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/invoices'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getInvoices.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getInvoices.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getInvoices.');
          }
          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }

          if (paid !== undefined) {
            queryParameters = queryParameters.set('paid', <any>paid);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get location message
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getLocationMessageWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/messages/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getLocationMessage.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getLocationMessage.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLocationMessage.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Returns list financial transactions
      * 
    * @param user 
    * @param startDate 
    * @param endDate 
    */
      public getTransactionsWithHttpInfo(user: string, startDate: string, endDate: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/transactions'
        .replace('${' + 'user' + '}', String(user));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getTransactions.');
          }
          // verify required parameter 'startDate' is not null or undefined
          if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getTransactions.');
          }
          // verify required parameter 'endDate' is not null or undefined
          if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getTransactions.');
          }
          if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
          }

          if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * uploads a csv in inserts bank transactions
      * 
    * @param user User ID
    * @param locationId location
    * @param additionalMetadata Additional data to pass to server
    * @param file file to upload
    */
      public importTransactionsWithHttpInfo(user: string, locationId: number, additionalMetadata?: string, file?: any, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/transaction/import'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling importTransactions.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling importTransactions.');
          }
        // to determine the Content-Type header
        let consumes: string[] = [
          'multipart/form-data'
        ];
        let canConsumeForm = this.canConsumeForm(consumes);
        let useForm = false;
            headers = headers.delete('Content-Type'); // needed for FormData to generate that header properly
            useForm = canConsumeForm;
        let formParams = new (useForm ? FormData : HttpParams as any)() as {
        set(param: string, value: any): void;
        };

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

          if (additionalMetadata !== undefined) {
          formParams.set('additionalMetadata', <any>additionalMetadata);
          }

          if (file !== undefined) {
          formParams.set('file', <any>file);
          }

      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: useForm ? formParams : formParams.toString(),
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Raises invoice
      * 
    * @param user 
    * @param id 
    * @param invoice 
    */
      public updateInvoiceWithHttpInfo(user: string, id: number, invoice: models.Invoice, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/invoice/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateInvoice.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateInvoice.');
          }
          // verify required parameter 'invoice' is not null or undefined
          if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling updateInvoice.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: invoice == null ? '' : JSON.stringify(invoice), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update location message
      * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param message 
    */
      public updateLocationMessageWithHttpInfo(user: string, locationId: number, id: number, message: models.LocationMessage, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/messages/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateLocationMessage.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateLocationMessage.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateLocationMessage.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling updateLocationMessage.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Updates a financial transaction
      * 
    * @param user 
    * @param id 
    * @param transaction 
    */
      public updateTransactionWithHttpInfo(user: string, id: number, transaction: models.Transaction, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/finance/transaction/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateTransaction.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTransaction.');
          }
          // verify required parameter 'transaction' is not null or undefined
          if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateTransaction.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: transaction == null ? '' : JSON.stringify(transaction), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }


    /**
    * @param consumes string[] mime-types
    * @return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (let consume of consumes) {
    if (form === consume) {
    return true;
    }
    }
    return false;
    }


    private searchToObject(): {[key :string]: string} {
    let pairs = window.location.search.substring(1).split("&"),
    obj = {},
    pair,
    i;

    for ( i in pairs ) {
    if ( pairs[i] === "" ) continue;

    pair = pairs[i].split("=");
    obj[ decodeURIComponent( pair[0] ) ] = decodeURIComponent( pair[1] );
    }

    return obj;
    }

    /**
    * Converts RequestMethod to string
    * @param {RequestMethod} method
    * @returns {string}
    */
    protected requestMethodToString(method: RequestMethod): string {
    switch (method) {
    case RequestMethod.Delete:
    return 'DELETE';

    case RequestMethod.Get:
    return 'GET';

    case RequestMethod.Head:
    return 'HEAD';

    case RequestMethod.Options:
    return 'OPTIONS';

    case RequestMethod.Patch:
    return 'PATCH';

    case RequestMethod.Post:
    return 'POST';

    case RequestMethod.Put:
    return 'PUT';

    default:
    throw 'Unknown method: ' + method;
    }
    }
    }
