/**
 * Creche YAML
 * This is Vivos Creche API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: smulhall79@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Child } from '../model/child';
import { ChildCalculations } from '../model/childCalculations';
import { ChildRequest } from '../model/childRequest';
import { ChildSchedule } from '../model/childSchedule';
import { Creche } from '../model/creche';
import { Family } from '../model/family';
import { Group } from '../model/group';
import { Guardian } from '../model/guardian';
import { Location } from '../model/location';
import { ScheduleAndFees } from '../model/scheduleAndFees';
import { Shift } from '../model/shift';
import { Staff } from '../model/staff';
import { StaffPayroll } from '../model/staffPayroll';
import { StaffRequest } from '../model/staffRequest';
import { TimeSheet } from '../model/timeSheet';
import { TimeSheetEntry } from '../model/timeSheetEntry';
import { WorkedShift } from '../model/workedShift';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class CrecheService {

    protected basePath = 'http://api-staging.childcareinnovations.com/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add child to system
     * add Child to system
     * @param user 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addChild(user: string, body: ChildRequest, observe?: 'body', reportProgress?: boolean): Observable<ChildRequest>;
    public addChild(user: string, body: ChildRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChildRequest>>;
    public addChild(user: string, body: ChildRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChildRequest>>;
    public addChild(user: string, body: ChildRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addChild.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addChild.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ChildRequest>(`${this.basePath}/${encodeURIComponent(String(user))}/child`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add Child schedule to system
     * Add Child schedule to system
     * @param user 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addChildSchedule(user: string, body: ChildSchedule, observe?: 'body', reportProgress?: boolean): Observable<ChildSchedule>;
    public addChildSchedule(user: string, body: ChildSchedule, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChildSchedule>>;
    public addChildSchedule(user: string, body: ChildSchedule, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChildSchedule>>;
    public addChildSchedule(user: string, body: ChildSchedule, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addChildSchedule.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addChildSchedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ChildSchedule>(`${this.basePath}/${encodeURIComponent(String(user))}/child/schedule`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param user 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addGroup(user: string, body: Group, observe?: 'body', reportProgress?: boolean): Observable<Group>;
    public addGroup(user: string, body: Group, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Group>>;
    public addGroup(user: string, body: Group, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Group>>;
    public addGroup(user: string, body: Group, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addGroup.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addGroup.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Group>(`${this.basePath}/${encodeURIComponent(String(user))}/group`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add staff member to system
     * add Staff to system
     * @param user 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addStaff(user: string, body: StaffRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addStaff(user: string, body: StaffRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addStaff(user: string, body: StaffRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addStaff(user: string, body: StaffRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addStaff.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addStaff.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/${encodeURIComponent(String(user))}/addStaff`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add staff shift to the system
     * Add staff shift to the system
     * @param user 
     * @param shift 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addStaffShift(user: string, shift: Shift, observe?: 'body', reportProgress?: boolean): Observable<Shift>;
    public addStaffShift(user: string, shift: Shift, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Shift>>;
    public addStaffShift(user: string, shift: Shift, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Shift>>;
    public addStaffShift(user: string, shift: Shift, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addStaffShift.');
        }
        if (shift === null || shift === undefined) {
            throw new Error('Required parameter shift was null or undefined when calling addStaffShift.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Shift>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/shift`,
            shift,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signs in or out a child
     * 
     * @param user 
     * @param location 
     * @param date 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public childTimes(user: string, location: number, date: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TimeSheet>>;
    public childTimes(user: string, location: number, date: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TimeSheet>>>;
    public childTimes(user: string, location: number, date: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TimeSheet>>>;
    public childTimes(user: string, location: number, date: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling childTimes.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling childTimes.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling childTimes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<TimeSheet>>(`${this.basePath}/${encodeURIComponent(String(user))}/child/times/${encodeURIComponent(String(location))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param user 
     * @param locationId 
     * @param groupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteGroup(user: string, locationId: number, groupId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteGroup(user: string, locationId: number, groupId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteGroup(user: string, locationId: number, groupId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteGroup(user: string, locationId: number, groupId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteGroup.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteGroup.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/${encodeURIComponent(String(user))}/group/${encodeURIComponent(String(locationId))}/${encodeURIComponent(String(groupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete staff shift from the system
     * Delete staff shift from the system. This shift is a planned shift not the actual worked one
     * @param user 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteStaffShift(user: string, id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteStaffShift(user: string, id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteStaffShift(user: string, id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteStaffShift(user: string, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteStaffShift.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteStaffShift.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/shift/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get child in the  system
     * get Child from the system
     * @param user 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChild(user: string, id: number, observe?: 'body', reportProgress?: boolean): Observable<ChildRequest>;
    public getChild(user: string, id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChildRequest>>;
    public getChild(user: string, id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChildRequest>>;
    public getChild(user: string, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChild.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChild.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ChildRequest>(`${this.basePath}/${encodeURIComponent(String(user))}/child/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Child schedules from system
     * Get Child schedules from system
     * @param user 
     * @param locationId 
     * @param groupId 
     * @param startDate 
     * @param endDate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildCalculations(user: string, locationId: number, groupId: number, startDate: string, endDate: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ChildCalculations>>;
    public getChildCalculations(user: string, locationId: number, groupId: number, startDate: string, endDate: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChildCalculations>>>;
    public getChildCalculations(user: string, locationId: number, groupId: number, startDate: string, endDate: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChildCalculations>>>;
    public getChildCalculations(user: string, locationId: number, groupId: number, startDate: string, endDate: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildCalculations.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildCalculations.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getChildCalculations.');
        }
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getChildCalculations.');
        }
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getChildCalculations.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ChildCalculations>>(`${this.basePath}/${encodeURIComponent(String(user))}/child/schedules/calculate/${encodeURIComponent(String(locationId))}/${encodeURIComponent(String(groupId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Child schedule from the system
     * Get Child schedule from the system
     * @param user 
     * @param childId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildSchedule(user: string, childId: number, observe?: 'body', reportProgress?: boolean): Observable<ChildSchedule>;
    public getChildSchedule(user: string, childId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChildSchedule>>;
    public getChildSchedule(user: string, childId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChildSchedule>>;
    public getChildSchedule(user: string, childId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildSchedule.');
        }
        if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling getChildSchedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ChildSchedule>(`${this.basePath}/${encodeURIComponent(String(user))}/child/schedule/${encodeURIComponent(String(childId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Child schedules from system
     * Get Child schedules from system
     * @param user 
     * @param location 
     * @param childIds 
     * @param startDate 
     * @param endDate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildSchedules(user: string, location: number, childIds: Array<number>, startDate: string, endDate: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getChildSchedules(user: string, location: number, childIds: Array<number>, startDate: string, endDate: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getChildSchedules(user: string, location: number, childIds: Array<number>, startDate: string, endDate: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getChildSchedules(user: string, location: number, childIds: Array<number>, startDate: string, endDate: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildSchedules.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getChildSchedules.');
        }
        if (childIds === null || childIds === undefined) {
            throw new Error('Required parameter childIds was null or undefined when calling getChildSchedules.');
        }
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getChildSchedules.');
        }
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getChildSchedules.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (childIds) {
            queryParameters = queryParameters.set('childIds', childIds.join(COLLECTION_FORMATS['csv']));
        }
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/${encodeURIComponent(String(user))}/child/schedules/${encodeURIComponent(String(location))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns times for a given child
     * 
     * @param user 
     * @param childId 
     * @param location 
     * @param date 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildTimes(user: string, childId: number, location: number, date: string, observe?: 'body', reportProgress?: boolean): Observable<TimeSheet>;
    public getChildTimes(user: string, childId: number, location: number, date: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TimeSheet>>;
    public getChildTimes(user: string, childId: number, location: number, date: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TimeSheet>>;
    public getChildTimes(user: string, childId: number, location: number, date: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildTimes.');
        }
        if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling getChildTimes.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getChildTimes.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling getChildTimes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TimeSheet>(`${this.basePath}/${encodeURIComponent(String(user))}/child-times/${encodeURIComponent(String(childId))}/${encodeURIComponent(String(location))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of children
     * 
     * @param user 
     * @param location 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildren(user: string, location: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Child>>;
    public getChildren(user: string, location: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Child>>>;
    public getChildren(user: string, location: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Child>>>;
    public getChildren(user: string, location: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildren.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getChildren.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Child>>(`${this.basePath}/${encodeURIComponent(String(user))}/children/${encodeURIComponent(String(location))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of children
     * 
     * @param user 
     * @param locationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildrenByGuardian(user: string, locationId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TimeSheet>>;
    public getChildrenByGuardian(user: string, locationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TimeSheet>>>;
    public getChildrenByGuardian(user: string, locationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TimeSheet>>>;
    public getChildrenByGuardian(user: string, locationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildrenByGuardian.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildrenByGuardian.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<TimeSheet>>(`${this.basePath}/${encodeURIComponent(String(user))}/${encodeURIComponent(String(locationId))}/children-guardian`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of children
     * 
     * @param user 
     * @param guardianId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildrenByGuardianId(user: string, guardianId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Child>>;
    public getChildrenByGuardianId(user: string, guardianId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Child>>>;
    public getChildrenByGuardianId(user: string, guardianId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Child>>>;
    public getChildrenByGuardianId(user: string, guardianId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildrenByGuardianId.');
        }
        if (guardianId === null || guardianId === undefined) {
            throw new Error('Required parameter guardianId was null or undefined when calling getChildrenByGuardianId.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Child>>(`${this.basePath}/${encodeURIComponent(String(user))}/children-guardian/${encodeURIComponent(String(guardianId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param user 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreche(user: string, observe?: 'body', reportProgress?: boolean): Observable<Creche>;
    public getCreche(user: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Creche>>;
    public getCreche(user: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Creche>>;
    public getCreche(user: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getCreche.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Creche>(`${this.basePath}/${encodeURIComponent(String(user))}/creche`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Default shifts from the system
     * Get Default shifts from the system
     * @param user 
     * @param locationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDefaultStaffShifts(user: string, locationId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Shift>>;
    public getDefaultStaffShifts(user: string, locationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Shift>>>;
    public getDefaultStaffShifts(user: string, locationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Shift>>>;
    public getDefaultStaffShifts(user: string, locationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getDefaultStaffShifts.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getDefaultStaffShifts.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Shift>>(`${this.basePath}/${encodeURIComponent(String(user))}/${encodeURIComponent(String(locationId))}/staff/shifts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of families in the system
     * 
     * @param user 
     * @param locationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFamilies(user: string, locationId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Family>>;
    public getFamilies(user: string, locationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Family>>>;
    public getFamilies(user: string, locationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Family>>>;
    public getFamilies(user: string, locationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getFamilies.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getFamilies.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Family>>(`${this.basePath}/${encodeURIComponent(String(user))}/families/${encodeURIComponent(String(locationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param user 
     * @param locationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroups(user: string, locationId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Group>>;
    public getGroups(user: string, locationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Group>>>;
    public getGroups(user: string, locationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Group>>>;
    public getGroups(user: string, locationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getGroups.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getGroups.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Group>>(`${this.basePath}/${encodeURIComponent(String(user))}/groups/${encodeURIComponent(String(locationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of guardians
     * 
     * @param user 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGuardians(user: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Guardian>>;
    public getGuardians(user: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Guardian>>>;
    public getGuardians(user: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Guardian>>>;
    public getGuardians(user: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getGuardians.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Guardian>>(`${this.basePath}/${encodeURIComponent(String(user))}/guardians`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param user 
     * @param crecheId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLocations(user: string, crecheId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Location>>;
    public getLocations(user: string, crecheId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Location>>>;
    public getLocations(user: string, crecheId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Location>>>;
    public getLocations(user: string, crecheId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getLocations.');
        }
        if (crecheId === null || crecheId === undefined) {
            throw new Error('Required parameter crecheId was null or undefined when calling getLocations.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Location>>(`${this.basePath}/${encodeURIComponent(String(user))}/locations/${encodeURIComponent(String(crecheId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of schedule types from system
     * GGet the list of schedule types from system
     * @param user 
     * @param locationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getScheduleTypes(user: string, locationId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ScheduleAndFees>>;
    public getScheduleTypes(user: string, locationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ScheduleAndFees>>>;
    public getScheduleTypes(user: string, locationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ScheduleAndFees>>>;
    public getScheduleTypes(user: string, locationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getScheduleTypes.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getScheduleTypes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ScheduleAndFees>>(`${this.basePath}/${encodeURIComponent(String(user))}/schedules/${encodeURIComponent(String(locationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of guardians
     * 
     * @param user 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaff(user: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Staff>>;
    public getStaff(user: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Staff>>>;
    public getStaff(user: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Staff>>>;
    public getStaff(user: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaff.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Staff>>(`${this.basePath}/${encodeURIComponent(String(user))}/staff`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get rota from the system for a given location
     * Get staff rota from the system for a given location
     * @param user 
     * @param locationId 
     * @param startDate 
     * @param endDate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaffRota(user: string, locationId: number, startDate: string, endDate: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Shift>>;
    public getStaffRota(user: string, locationId: number, startDate: string, endDate: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Shift>>>;
    public getStaffRota(user: string, locationId: number, startDate: string, endDate: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Shift>>>;
    public getStaffRota(user: string, locationId: number, startDate: string, endDate: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffRota.');
        }
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getStaffRota.');
        }
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getStaffRota.');
        }
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getStaffRota.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Shift>>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/rota/${encodeURIComponent(String(locationId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a staff shift from the system
     * Get staff shift from the system. This returns the planned shift not the acutal worked one
     * @param user 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaffShift(user: string, id: number, observe?: 'body', reportProgress?: boolean): Observable<Shift>;
    public getStaffShift(user: string, id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Shift>>;
    public getStaffShift(user: string, id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Shift>>;
    public getStaffShift(user: string, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffShift.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStaffShift.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Shift>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/shift/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns staff timesheet for today
     * 
     * @param user 
     * @param location 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaffTimes(user: string, location: number, observe?: 'body', reportProgress?: boolean): Observable<TimeSheet>;
    public getStaffTimes(user: string, location: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TimeSheet>>;
    public getStaffTimes(user: string, location: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TimeSheet>>;
    public getStaffTimes(user: string, location: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimes.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TimeSheet>(`${this.basePath}/${encodeURIComponent(String(user))}/staff-times/${encodeURIComponent(String(location))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets staff payroll numbers
     * 
     * @param user 
     * @param location 
     * @param startDate 
     * @param endDate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaffTimesAndPayroll(user: string, location: number, startDate: string, endDate: string, observe?: 'body', reportProgress?: boolean): Observable<Array<StaffPayroll>>;
    public getStaffTimesAndPayroll(user: string, location: number, startDate: string, endDate: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<StaffPayroll>>>;
    public getStaffTimesAndPayroll(user: string, location: number, startDate: string, endDate: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<StaffPayroll>>>;
    public getStaffTimesAndPayroll(user: string, location: number, startDate: string, endDate: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimesAndPayroll.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimesAndPayroll.');
        }
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getStaffTimesAndPayroll.');
        }
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getStaffTimesAndPayroll.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<StaffPayroll>>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/payroll/${encodeURIComponent(String(location))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets staff payroll numbers
     * 
     * @param user 
     * @param location 
     * @param startDate 
     * @param endDate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaffTimesAndPayrollV2(user: string, location: number, startDate: string, endDate: string, observe?: 'body', reportProgress?: boolean): Observable<Array<StaffPayroll>>;
    public getStaffTimesAndPayrollV2(user: string, location: number, startDate: string, endDate: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<StaffPayroll>>>;
    public getStaffTimesAndPayrollV2(user: string, location: number, startDate: string, endDate: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<StaffPayroll>>>;
    public getStaffTimesAndPayrollV2(user: string, location: number, startDate: string, endDate: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimesAndPayrollV2.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimesAndPayrollV2.');
        }
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getStaffTimesAndPayrollV2.');
        }
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getStaffTimesAndPayrollV2.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<StaffPayroll>>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/payroll/v2/${encodeURIComponent(String(location))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return times for a given staff
     * 
     * @param user 
     * @param staffId 
     * @param location 
     * @param date 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStaffTimesById(user: string, staffId: number, location: number, date: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TimeSheet>>;
    public getStaffTimesById(user: string, staffId: number, location: number, date: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TimeSheet>>>;
    public getStaffTimesById(user: string, staffId: number, location: number, date: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TimeSheet>>>;
    public getStaffTimesById(user: string, staffId: number, location: number, date: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getStaffTimesById.');
        }
        if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling getStaffTimesById.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getStaffTimesById.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling getStaffTimesById.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<TimeSheet>>(`${this.basePath}/${encodeURIComponent(String(user))}/staff-times/${encodeURIComponent(String(staffId))}/${encodeURIComponent(String(location))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove child from system
     * remove Child from system
     * @param user 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeChild(user: string, id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeChild(user: string, id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeChild(user: string, id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeChild(user: string, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling removeChild.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeChild.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/${encodeURIComponent(String(user))}/child/remove/${encodeURIComponent(String(id))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove Staff from system
     * remove Staff from system
     * @param user 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeStaff(user: string, id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeStaff(user: string, id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeStaff(user: string, id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeStaff(user: string, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling removeStaff.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeStaff.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/remove/${encodeURIComponent(String(id))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Resets times for children
     * 
     * @param user 
     * @param childId 
     * @param date Sign in/out info
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetChildTimes(user: string, childId: number, date: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetChildTimes(user: string, childId: number, date: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetChildTimes(user: string, childId: number, date: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetChildTimes(user: string, childId: number, date: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling resetChildTimes.');
        }
        if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling resetChildTimes.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling resetChildTimes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/${encodeURIComponent(String(user))}/child/reset-times/${encodeURIComponent(String(childId))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Resets times for staff
     * 
     * @param user 
     * @param staffId 
     * @param date Sign in/out info
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetStaffTimes(user: string, staffId: number, date: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetStaffTimes(user: string, staffId: number, date: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetStaffTimes(user: string, staffId: number, date: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetStaffTimes(user: string, staffId: number, date: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling resetStaffTimes.');
        }
        if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling resetStaffTimes.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling resetStaffTimes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/reset-times/${encodeURIComponent(String(staffId))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signs in or out a child
     * 
     * @param user 
     * @param location 
     * @param childId 
     * @param body Sign in/out info
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signInOutChild(user: string, location: number, childId: number, body: TimeSheetEntry, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public signInOutChild(user: string, location: number, childId: number, body: TimeSheetEntry, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public signInOutChild(user: string, location: number, childId: number, body: TimeSheetEntry, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public signInOutChild(user: string, location: number, childId: number, body: TimeSheetEntry, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling signInOutChild.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling signInOutChild.');
        }
        if (childId === null || childId === undefined) {
            throw new Error('Required parameter childId was null or undefined when calling signInOutChild.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signInOutChild.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/${encodeURIComponent(String(user))}/child/sign-in-out/${encodeURIComponent(String(location))}/${encodeURIComponent(String(childId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signs in or out a staff
     * 
     * @param user 
     * @param location 
     * @param staffId 
     * @param body Sign in/out info
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signInOutStaff(user: string, location: number, staffId: number, body: TimeSheetEntry, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public signInOutStaff(user: string, location: number, staffId: number, body: TimeSheetEntry, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public signInOutStaff(user: string, location: number, staffId: number, body: TimeSheetEntry, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public signInOutStaff(user: string, location: number, staffId: number, body: TimeSheetEntry, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling signInOutStaff.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling signInOutStaff.');
        }
        if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling signInOutStaff.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signInOutStaff.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/sign-in-out/${encodeURIComponent(String(location))}/${encodeURIComponent(String(staffId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signs in or out a child
     * 
     * @param user 
     * @param location 
     * @param date 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public staffTimes(user: string, location: number, date: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TimeSheet>>;
    public staffTimes(user: string, location: number, date: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TimeSheet>>>;
    public staffTimes(user: string, location: number, date: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TimeSheet>>>;
    public staffTimes(user: string, location: number, date: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling staffTimes.');
        }
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling staffTimes.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling staffTimes.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<TimeSheet>>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/times/${encodeURIComponent(String(location))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update child in the system
     * Update Child in the system
     * @param user 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateChild(user: string, body: ChildRequest, observe?: 'body', reportProgress?: boolean): Observable<ChildRequest>;
    public updateChild(user: string, body: ChildRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChildRequest>>;
    public updateChild(user: string, body: ChildRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChildRequest>>;
    public updateChild(user: string, body: ChildRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateChild.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateChild.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ChildRequest>(`${this.basePath}/${encodeURIComponent(String(user))}/child`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Child schedule to system
     * Update Child schedule to system
     * @param user 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateChildSchedule(user: string, body: ChildSchedule, observe?: 'body', reportProgress?: boolean): Observable<ChildSchedule>;
    public updateChildSchedule(user: string, body: ChildSchedule, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChildSchedule>>;
    public updateChildSchedule(user: string, body: ChildSchedule, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChildSchedule>>;
    public updateChildSchedule(user: string, body: ChildSchedule, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateChildSchedule.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateChildSchedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ChildSchedule>(`${this.basePath}/${encodeURIComponent(String(user))}/child/schedule`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update staff shift to the system
     * Update staff shift to the system
     * @param user 
     * @param id 
     * @param shift 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateStaffShift(user: string, id: number, shift: Shift, observe?: 'body', reportProgress?: boolean): Observable<Shift>;
    public updateStaffShift(user: string, id: number, shift: Shift, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Shift>>;
    public updateStaffShift(user: string, id: number, shift: Shift, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Shift>>;
    public updateStaffShift(user: string, id: number, shift: Shift, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateStaffShift.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateStaffShift.');
        }
        if (shift === null || shift === undefined) {
            throw new Error('Required parameter shift was null or undefined when calling updateStaffShift.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<Shift>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/shift/${encodeURIComponent(String(id))}`,
            shift,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a worked staff shift
     * Updates a worked staff shift
     * @param user 
     * @param id 
     * @param shift 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateWorkedShift(user: string, id: number, shift: WorkedShift, observe?: 'body', reportProgress?: boolean): Observable<WorkedShift>;
    public updateWorkedShift(user: string, id: number, shift: WorkedShift, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorkedShift>>;
    public updateWorkedShift(user: string, id: number, shift: WorkedShift, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorkedShift>>;
    public updateWorkedShift(user: string, id: number, shift: WorkedShift, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateWorkedShift.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateWorkedShift.');
        }
        if (shift === null || shift === undefined) {
            throw new Error('Required parameter shift was null or undefined when calling updateWorkedShift.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<WorkedShift>(`${this.basePath}/${encodeURIComponent(String(user))}/staff/worked-shift/${encodeURIComponent(String(id))}`,
            shift,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
