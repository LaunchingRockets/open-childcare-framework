/* tslint:disable */
/**
 * Creche YAML
 * This is Vivos Creche API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: smulhall79@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import {RequestMethod} from '@angular/http';
import {HttpClient, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../models/models';
import { COLLECTION_FORMATS }                     from '../variables';


  @Injectable()
  export class ClassroomApi {
  protected basePath = 'http://__HOST__/v1';
  protected apiKey: string;
  protected accessToken: string;

  constructor(protected http: HttpClient) {

  }

  public setApiKey(apiKey:string) {
  this.apiKey = apiKey;
  }

  public setToken(token:string) {
  this.accessToken = token;
  }

  public setBasePath(basePath:string) {
  this.basePath = basePath;
  }

    /**
    * Add Child Data Entry
    * 
    * @param user 
    * @param locationId 
    * @param message 
    * @param children 
    */
      public addChildEntry(user: string, locationId: number, message: models.ChildClassData, children: Array<number>, extraHttpRequestParams?: any): Observable<models.ChildClassData> {
    return this.addChildEntryWithHttpInfo(user, locationId, message, children, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Ingredient
    * 
    * @param user 
    * @param locationId 
    * @param ingredient 
    */
      public addIngredient(user: string, locationId: number, ingredient: models.Ingredient, extraHttpRequestParams?: any): Observable<models.Ingredient> {
    return this.addIngredientWithHttpInfo(user, locationId, ingredient, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Meal
    * 
    * @param user 
    * @param locationId 
    * @param message 
    */
      public addMeal(user: string, locationId: number, message: models.Meal, extraHttpRequestParams?: any): Observable<models.Meal> {
    return this.addMealWithHttpInfo(user, locationId, message, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Menu
    * 
    * @param user 
    * @param locationId 
    * @param message 
    */
      public addMenu(user: string, locationId: number, message: models.Menu, extraHttpRequestParams?: any): Observable<models.Menu> {
    return this.addMenuWithHttpInfo(user, locationId, message, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Observation
    * 
    * @param user 
    * @param locationId 
    * @param message 
    * @param children 
    */
      public addObservations(user: string, locationId: number, message: models.Observation, children?: Array<number>, extraHttpRequestParams?: any): Observable<{}> {
    return this.addObservationsWithHttpInfo(user, locationId, message, children, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Supplier
    * 
    * @param user 
    * @param locationId 
    * @param supplier 
    */
      public addSupplier(user: string, locationId: number, supplier: models.Supplier, extraHttpRequestParams?: any): Observable<models.Supplier> {
    return this.addSupplierWithHttpInfo(user, locationId, supplier, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * delete child data entry
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteChildEntry(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteChildEntryWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Delete Ingredient
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteIngredient(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteIngredientWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Delete Meal
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteMeal(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteMealWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Delete Menu
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteMenu(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteMenuWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Delete Observation
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteObservation(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteObservationWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get child data entries
    * 
    * @param user 
    * @param locationId 
    * @param children 
    * @param startTime 
    * @param endTime 
    * @param type 
    */
      public getChildEntries(user: string, locationId: number, children: Array<number>, startTime?: string, endTime?: string, type?: string, extraHttpRequestParams?: any): Observable<Array<models.ChildClassData>> {
    return this.getChildEntriesWithHttpInfo(user, locationId, children, startTime, endTime, type, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get child data entries
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getChildEntry(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<Array<models.ChildClassData>> {
    return this.getChildEntryWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get observations
    * 
    * @param user 
    * @param locationId 
    * @param startTime 
    * @param endTime 
    * @param children 
    */
      public getChildObservations(user: string, locationId: number, startTime?: string, endTime?: string, children?: Array<number>, extraHttpRequestParams?: any): Observable<Array<models.Observation>> {
    return this.getChildObservationsWithHttpInfo(user, locationId, startTime, endTime, children, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get observations
    * 
    * @param user 
    * @param locationId 
    * @param groupId 
    * @param startTime 
    * @param endTime 
    */
      public getGroupObservations(user: string, locationId: number, groupId: number, startTime?: string, endTime?: string, extraHttpRequestParams?: any): Observable<Array<models.Observation>> {
    return this.getGroupObservationsWithHttpInfo(user, locationId, groupId, startTime, endTime, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Ingredients
    * 
    * @param user 
    * @param locationId 
    */
      public getIngredients(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Ingredient>> {
    return this.getIngredientsWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Meals
    * 
    * @param user 
    * @param locationId 
    */
      public getMeals(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Meal>> {
    return this.getMealsWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get Menu
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getMenuById(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<models.Menu> {
    return this.getMenuByIdWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get menu
    * 
    * @param user 
    * @param locationId 
    */
      public getMenus(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Menu>> {
    return this.getMenusWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get Observation
    * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getObservation(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<models.Observation> {
    return this.getObservationWithHttpInfo(user, locationId, id, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Get Suppliers
    * 
    * @param user 
    * @param locationId 
    */
      public getSuppliers(user: string, locationId: number, extraHttpRequestParams?: any): Observable<Array<models.Supplier>> {
    return this.getSuppliersWithHttpInfo(user, locationId, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * get Aister tags
    * 
    * @param user 
    * @param locationId 
    * @param type 
    */
      public getTags(user: string, locationId: number, type: string, extraHttpRequestParams?: any): Observable<models.AistearFramework> {
    return this.getTagsWithHttpInfo(user, locationId, type, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Add Child Data Entry
    * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param message 
    */
      public updateChildEntry(user: string, locationId: number, id: number, message: models.ChildClassData, extraHttpRequestParams?: any): Observable<models.ChildClassData> {
    return this.updateChildEntryWithHttpInfo(user, locationId, id, message, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update Ingredient
    * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param ingredient 
    */
      public updateIngredient(user: string, locationId: number, id: number, ingredient: models.Ingredient, extraHttpRequestParams?: any): Observable<models.Ingredient> {
    return this.updateIngredientWithHttpInfo(user, locationId, id, ingredient, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update Meal
    * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param meal 
    */
      public updateMeal(user: string, locationId: number, id: number, meal: models.Meal, extraHttpRequestParams?: any): Observable<models.Meal> {
    return this.updateMealWithHttpInfo(user, locationId, id, meal, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update Menu
    * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param menu 
    */
      public updateMenu(user: string, locationId: number, id: number, menu: models.Menu, extraHttpRequestParams?: any): Observable<models.Menu> {
    return this.updateMenuWithHttpInfo(user, locationId, id, menu, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }

    /**
    * Update Observation
    * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param message 
    */
      public updateObservation(user: string, locationId: number, id: number, message: models.Observation, extraHttpRequestParams?: any): Observable<models.Observation> {
    return this.updateObservationWithHttpInfo(user, locationId, id, message, extraHttpRequestParams)
    .map((response: HttpResponse<any>) => {
      if (response.status === 204) {
      return undefined;
      } else {
        return response.body || {};
      }
      });
      }


      /**
      * Add Child Data Entry
      * 
    * @param user 
    * @param locationId 
    * @param message 
    * @param children 
    */
      public addChildEntryWithHttpInfo(user: string, locationId: number, message: models.ChildClassData, children: Array<number>, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/class'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addChildEntry.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addChildEntry.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling addChildEntry.');
          }
          // verify required parameter 'children' is not null or undefined
          if (children === null || children === undefined) {
            throw new Error('Required parameter children was null or undefined when calling addChildEntry.');
          }
          if (children) {
            queryParameters = queryParameters.set('children', children.join(COLLECTION_FORMATS['csv']));
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Ingredient
      * 
    * @param user 
    * @param locationId 
    * @param ingredient 
    */
      public addIngredientWithHttpInfo(user: string, locationId: number, ingredient: models.Ingredient, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/ingredients'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addIngredient.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addIngredient.');
          }
          // verify required parameter 'ingredient' is not null or undefined
          if (ingredient === null || ingredient === undefined) {
            throw new Error('Required parameter ingredient was null or undefined when calling addIngredient.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: ingredient == null ? '' : JSON.stringify(ingredient), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Meal
      * 
    * @param user 
    * @param locationId 
    * @param message 
    */
      public addMealWithHttpInfo(user: string, locationId: number, message: models.Meal, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/meals'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addMeal.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addMeal.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling addMeal.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Menu
      * 
    * @param user 
    * @param locationId 
    * @param message 
    */
      public addMenuWithHttpInfo(user: string, locationId: number, message: models.Menu, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/menus'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addMenu.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addMenu.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling addMenu.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Observation
      * 
    * @param user 
    * @param locationId 
    * @param message 
    * @param children 
    */
      public addObservationsWithHttpInfo(user: string, locationId: number, message: models.Observation, children?: Array<number>, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observations'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addObservations.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addObservations.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling addObservations.');
          }
          if (children) {
            queryParameters = queryParameters.set('children', children.join(COLLECTION_FORMATS['csv']));
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Supplier
      * 
    * @param user 
    * @param locationId 
    * @param supplier 
    */
      public addSupplierWithHttpInfo(user: string, locationId: number, supplier: models.Supplier, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/suppliers'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addSupplier.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling addSupplier.');
          }
          // verify required parameter 'supplier' is not null or undefined
          if (supplier === null || supplier === undefined) {
            throw new Error('Required parameter supplier was null or undefined when calling addSupplier.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Post), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: supplier == null ? '' : JSON.stringify(supplier), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * delete child data entry
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteChildEntryWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/class/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteChildEntry.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteChildEntry.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChildEntry.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Delete Ingredient
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteIngredientWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/ingredients/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteIngredient.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteIngredient.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteIngredient.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Delete Meal
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteMealWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/meal/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteMeal.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteMeal.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMeal.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Delete Menu
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteMenuWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/menu/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteMenu.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteMenu.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMenu.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Delete Observation
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public deleteObservationWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observations/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteObservation.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteObservation.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteObservation.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Delete), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get child data entries
      * 
    * @param user 
    * @param locationId 
    * @param children 
    * @param startTime 
    * @param endTime 
    * @param type 
    */
      public getChildEntriesWithHttpInfo(user: string, locationId: number, children: Array<number>, startTime?: string, endTime?: string, type?: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/class'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildEntries.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildEntries.');
          }
          // verify required parameter 'children' is not null or undefined
          if (children === null || children === undefined) {
            throw new Error('Required parameter children was null or undefined when calling getChildEntries.');
          }
          if (children) {
            queryParameters = queryParameters.set('children', children.join(COLLECTION_FORMATS['csv']));
          }

          if (startTime !== undefined) {
            queryParameters = queryParameters.set('startTime', <any>startTime);
          }

          if (endTime !== undefined) {
            queryParameters = queryParameters.set('endTime', <any>endTime);
          }

          if (type !== undefined) {
            queryParameters = queryParameters.set('type', <any>type);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get child data entries
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getChildEntryWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/class/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildEntry.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildEntry.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChildEntry.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get observations
      * 
    * @param user 
    * @param locationId 
    * @param startTime 
    * @param endTime 
    * @param children 
    */
      public getChildObservationsWithHttpInfo(user: string, locationId: number, startTime?: string, endTime?: string, children?: Array<number>, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observations'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getChildObservations.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getChildObservations.');
          }
          if (startTime !== undefined) {
            queryParameters = queryParameters.set('startTime', <any>startTime);
          }

          if (endTime !== undefined) {
            queryParameters = queryParameters.set('endTime', <any>endTime);
          }

          if (children) {
            queryParameters = queryParameters.set('children', children.join(COLLECTION_FORMATS['csv']));
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get observations
      * 
    * @param user 
    * @param locationId 
    * @param groupId 
    * @param startTime 
    * @param endTime 
    */
      public getGroupObservationsWithHttpInfo(user: string, locationId: number, groupId: number, startTime?: string, endTime?: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observations/group'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getGroupObservations.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getGroupObservations.');
          }
          // verify required parameter 'groupId' is not null or undefined
          if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getGroupObservations.');
          }
          if (startTime !== undefined) {
            queryParameters = queryParameters.set('startTime', <any>startTime);
          }

          if (endTime !== undefined) {
            queryParameters = queryParameters.set('endTime', <any>endTime);
          }

          if (groupId !== undefined) {
            queryParameters = queryParameters.set('groupId', <any>groupId);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Ingredients
      * 
    * @param user 
    * @param locationId 
    */
      public getIngredientsWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/ingredients'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getIngredients.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getIngredients.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Meals
      * 
    * @param user 
    * @param locationId 
    */
      public getMealsWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/meals'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMeals.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getMeals.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get Menu
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getMenuByIdWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/menu/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMenuById.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getMenuById.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMenuById.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get menu
      * 
    * @param user 
    * @param locationId 
    */
      public getMenusWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/menus'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMenus.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getMenus.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get Observation
      * 
    * @param user 
    * @param locationId 
    * @param id 
    */
      public getObservationWithHttpInfo(user: string, locationId: number, id: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observations/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getObservation.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getObservation.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getObservation.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Get Suppliers
      * 
    * @param user 
    * @param locationId 
    */
      public getSuppliersWithHttpInfo(user: string, locationId: number, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/suppliers'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getSuppliers.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getSuppliers.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * get Aister tags
      * 
    * @param user 
    * @param locationId 
    * @param type 
    */
      public getTagsWithHttpInfo(user: string, locationId: number, type: string, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observation-tags'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getTags.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling getTags.');
          }
          // verify required parameter 'type' is not null or undefined
          if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getTags.');
          }
          if (type !== undefined) {
            queryParameters = queryParameters.set('type', <any>type);
          }


      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];

      return this.http.request(this.requestMethodToString(RequestMethod.Get), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Add Child Data Entry
      * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param message 
    */
      public updateChildEntryWithHttpInfo(user: string, locationId: number, id: number, message: models.ChildClassData, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/class/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateChildEntry.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateChildEntry.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChildEntry.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling updateChildEntry.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update Ingredient
      * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param ingredient 
    */
      public updateIngredientWithHttpInfo(user: string, locationId: number, id: number, ingredient: models.Ingredient, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/ingredients/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateIngredient.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateIngredient.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateIngredient.');
          }
          // verify required parameter 'ingredient' is not null or undefined
          if (ingredient === null || ingredient === undefined) {
            throw new Error('Required parameter ingredient was null or undefined when calling updateIngredient.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: ingredient == null ? '' : JSON.stringify(ingredient), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update Meal
      * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param meal 
    */
      public updateMealWithHttpInfo(user: string, locationId: number, id: number, meal: models.Meal, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/meal/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateMeal.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateMeal.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMeal.');
          }
          // verify required parameter 'meal' is not null or undefined
          if (meal === null || meal === undefined) {
            throw new Error('Required parameter meal was null or undefined when calling updateMeal.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: meal == null ? '' : JSON.stringify(meal), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update Menu
      * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param menu 
    */
      public updateMenuWithHttpInfo(user: string, locationId: number, id: number, menu: models.Menu, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/menu/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateMenu.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateMenu.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMenu.');
          }
          // verify required parameter 'menu' is not null or undefined
          if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: menu == null ? '' : JSON.stringify(menu), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }

      /**
      * Update Observation
      * 
    * @param user 
    * @param locationId 
    * @param id 
    * @param message 
    */
      public updateObservationWithHttpInfo(user: string, locationId: number, id: number, message: models.Observation, extraHttpRequestParams?: any): Observable<HttpResponse<any>> {
      const path = this.basePath + '/{user}/{locationId}/observations/{id}'
        .replace('${' + 'user' + '}', String(user))
        .replace('${' + 'locationId' + '}', String(locationId))
        .replace('${' + 'id' + '}', String(id));

      let queryParameters = new HttpParams();

      let headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      });

      if (this.accessToken) {
        headers = headers.append('Authorization', this.accessToken);
      }

      if (this.apiKey) {
        headers = headers.append('Api-Key', this.apiKey);
      }

          // verify required parameter 'user' is not null or undefined
          if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateObservation.');
          }
          // verify required parameter 'locationId' is not null or undefined
          if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateObservation.');
          }
          // verify required parameter 'id' is not null or undefined
          if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateObservation.');
          }
          // verify required parameter 'message' is not null or undefined
          if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling updateObservation.');
          }

      // to determine the Accept header
      let produces: string[] = [
        'application/json'
      ];


      return this.http.request(this.requestMethodToString(RequestMethod.Put), path, {
      headers: headers,
      observe: 'response',
      responseType: 'json',
        body: message == null ? '' : JSON.stringify(message), // https://github.com/angular/angular/issues/10612
      params: queryParameters,
      }) as any; // here is some issue with casting because of the spread operator
      }


    /**
    * @param consumes string[] mime-types
    * @return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (let consume of consumes) {
    if (form === consume) {
    return true;
    }
    }
    return false;
    }


    private searchToObject(): {[key :string]: string} {
    let pairs = window.location.search.substring(1).split("&"),
    obj = {},
    pair,
    i;

    for ( i in pairs ) {
    if ( pairs[i] === "" ) continue;

    pair = pairs[i].split("=");
    obj[ decodeURIComponent( pair[0] ) ] = decodeURIComponent( pair[1] );
    }

    return obj;
    }

    /**
    * Converts RequestMethod to string
    * @param {RequestMethod} method
    * @returns {string}
    */
    protected requestMethodToString(method: RequestMethod): string {
    switch (method) {
    case RequestMethod.Delete:
    return 'DELETE';

    case RequestMethod.Get:
    return 'GET';

    case RequestMethod.Head:
    return 'HEAD';

    case RequestMethod.Options:
    return 'OPTIONS';

    case RequestMethod.Patch:
    return 'PATCH';

    case RequestMethod.Post:
    return 'POST';

    case RequestMethod.Put:
    return 'PUT';

    default:
    throw 'Unknown method: ' + method;
    }
    }
    }
